import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { selectChatMessages } from "../../redux/selectors/chatSelectors";
import MessageDiv from "./MessageDiv";
import styled from "styled-components";
import { addMessage } from "../../redux/slices/chatSlice";
import { AnyAction, Dispatch } from "@reduxjs/toolkit";
import { closeStream, streamUpdate } from "../../redux/slices/chatSlice";
import { ChatMessage, RootStore } from "../../redux/store";
import { postVscMessage, vscRequest } from "../../vscode";

function streamToStateThunk(
  dispatch: Dispatch<AnyAction>,
  getResponse: () => Promise<Response>
) {
  getResponse().then((resp) => {
    if (resp.body) {
      resp.body.pipeTo(
        new WritableStream({
          write(chunk) {
            let update = new TextDecoder("utf-8").decode(chunk);
            dispatch(streamUpdate(update));
          },
          close() {
            dispatch(closeStream());
          },
        })
      );
    }
  });
}

const ChatContainer = styled.div`
  display: grid;
  grid-template-rows: 1fr 20px;
  height: 100%;
`;

const TextEntryBar = styled.input`
  width: 100%;
  height: 20px;
  border-radius: 16px;
  padding: 8px;
  border: 1px solid white;
  background-color: black;
  color: white;
`;

function ChatTab() {
  const dispatch = useDispatch();
  const chatMessages = useSelector(selectChatMessages);
  const isStreaming = useSelector((state: RootStore) => state.chat.isStreaming);
  const baseUrl = useSelector((state: RootStore) => state.config.apiUrl);

  useEffect(() => {
    if (
      chatMessages.length > 0 &&
      chatMessages[chatMessages.length - 1].role === "user" &&
      !isStreaming
    ) {
      streamToStateThunk(dispatch, async () => {
        if (chatMessages.length === 0) {
          return new Promise((resolve, _) => resolve(new Response()));
        }

        return vscRequest("queryEmbeddings", {
          query: chatMessages[chatMessages.length - 1].content,
        }).then((data: any) => {
          let codeContextMessages = data.results.map(
            (result: { id: string; document: string }) => {
              let msg: ChatMessage = {
                role: "user",
                content: `File: ${result.id} \n ${result.document}`,
              };
              return msg;
            }
          );
          codeContextMessages.push({
            role: "user",
            content:
              "Use the above code to help you answer the question below. Answer in asterisk bullet points, and give the full path whenever you reference files.",
          });
          let augmentedMessages = [
            ...chatMessages.slice(0, -1),
            ...codeContextMessages,
            chatMessages[chatMessages.length - 1],
          ];

          console.log(augmentedMessages);

          // The autogenerated client can't handle streams, so have to go raw
          return fetch(`${baseUrl}/chat/complete`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              messages: augmentedMessages,
            }),
          });
        });
      });
    }
  }, [chatMessages, dispatch, isStreaming]);

  return (
    <ChatContainer>
      <h1>Chat</h1>
      {chatMessages.map((message, idx) => {
        return <MessageDiv key={idx} {...message}></MessageDiv>;
      })}
      <TextEntryBar
        type="text"
        placeholder="Enter your message here"
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            dispatch(
              addMessage({ content: e.currentTarget.value, role: "user" })
            );
            (e.target as any).value = "";
          }
        }}
      ></TextEntryBar>
    </ChatContainer>
  );
}

export default ChatTab;
